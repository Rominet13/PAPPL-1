<!DOCTYPE html>
<meta charset="utf-8">
<html>
    <head>
        <title>Réseau de Régulation Biologique</title>
        <script src="d3.v2.js"></script>
        <script type="text/javascript" src="jquery-1.10.2.js"></script>
        <script type='text/javascript' src="jquery-ui.js"> </script>
        <link rel="stylesheet" type="text/css" href="style.css">
        <center>
            <h1><i>Réseau de Régulation Biologique - MeForBio</i></h1>
            Carlos Eduardo <b>GRIVOL JÚNIOR</b> / Romain <b>GIUDICE</b>
            <br><br>
            <button onclick="aide()">Aide</button>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
            <button onclick="clicks()">Ouvrir/Fermer</button>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
            <a href="whatever.htm" onClick="window.print();return false"><img src="printer.png"></a>
            <br><br>
            <div class="ui-widget">
                <label for="search">Gène: </label>
                <select id="search"></select>
                <button type="button" onclick="searchNode()">Chercher</button>
            </div>
            <br>
        </center>
    </head>
    <body>
        <script type="text/javascript">
            var width = 960,     // largeur svg
                height = 600,     // hauteur svg
                dr = 12,      // rayon des noeuds
                off = 14,    // offset des englobements
                expand = {}, // clusters
                data, net, force, hullg, hull, linkg, link, nodeg, node;
            
            var curve = d3.svg.line()
                .interpolate("cardinal-closed")
                .tension(.9);
            
            var fill = d3.scale.category10();
            
            jQuery.fn.d3Click = function () {
              this.each(function (i, e) {
                var evt = document.createEvent("MouseEvents");
                evt.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            
                e.dispatchEvent(evt);
              });
            };
            
            function noop() { return false; }
            
            var nbclicks = 0;
            
            function clicks() { 
            if(nbclicks==0){
            	$("path.hull").d3Click();
            	nbclicks=1;
            }
            else{
            	$("circle").d3Click();
            	nbclicks=0;
            }
            }
            
            function aide() { 
            	alert("Noeuds -> Tapez Shift pour activer et Ctrl pour déactiver avant de passer la souris sur le noeud \n \n Liens -> Tapez Shift pour rouge, Alt pour vert et Ctrl pour noir avant de passer la souris sur le noeud \n \n Bouton Ouvrir/Fermer -> Appuyez pour voire l'intérieur de tous les gènes ou pour cacher les niveaux des gènes \n \n Chercher-> Choisissez le gène souhaité pour le trouver facilement \n \n");
            	alert("Zoom -> Il est possible de zoomer et dézoomer à n'importe quel niveau avec le bouton central de la souris si elle est bien placé sur un noeud \n \n Traînée -> Vous pouvez déplacer librement les noeuds et ils seront fixés après les lâcher \n \n Clicker -> Un click sur un gène lui fait démonter et un click sur un niveau du gène réalise l'assemblage de tous les niveaux du gène \n \n");
            }
            
            function nodeid(n) {
              return n.size ? "_g_"+n.group : n.name;
            }
            
            function linkid(l) {
              var u = nodeid(l.source),
                  v = nodeid(l.target);
              return u<v ? u+"|"+v : v+"|"+u;
            }
            
            function getGroup(n) { return n.group; }
            
            // constructs the network to visualize
            function network(data, prev, index, expand) {
              expand = expand || {};
              var gm = {},    // group map
                  nm = {},    // node map
                  lm = {},    // link map
                  gn = {},    // previous group nodes
                  gc = {},    // previous group centroids
                  nodes = [], // output nodes
                  links = []; // output links
            
              // process previous nodes for reuse or centroid calculation
              if (prev) {
                prev.nodes.forEach(function(n) {
                  var i = index(n), o;
                  if (n.size > 0) {
                    gn[i] = n;
                    n.size = 0;
                  } else {
                    o = gc[i] || (gc[i] = {x:0,y:0,count:0});
                    o.x += n.x;
                    o.y += n.y;
                    o.count += 1;
                  }
                });
              }
            
              // determine nodes
              for (var k=0; k<data.nodes.length; ++k) {
                var n = data.nodes[k],
                    i = index(n),
                    l = gm[i] || (gm[i]=gn[i]) || (gm[i]={group:i, name:n.name, gene:n.gene, level:n.level, value:n.value, size:0, nodes:[]});
            
                if (expand[i]) {
                  // the node should be directly visible
                  nm[n.name] = nodes.length;
                  nodes.push(n);
                  if (gn[i]) {
                    // place new nodes at cluster location (plus jitter)
                    n.x = gn[i].x + Math.random();
                    n.y = gn[i].y + Math.random();
                  }
                } else {
                  // the node is part of a collapsed cluster
                  if (l.size == 0) {
                    // if new cluster, add to set and position at centroid of leaf nodes
                    nm[i] = nodes.length;
                    nodes.push(l);
                    if (gc[i]) {
                      l.x = gc[i].x / gc[i].count;
                      l.y = gc[i].y / gc[i].count;
                    }
                  }
                  l.nodes.push(n);
                }
              // always count group size as we also use it to tweak the force graph strengths/distances
                l.size += 1;
              n.group_data = l;
              }
            
              for (i in gm) { gm[i].link_count = 0; }
            
              // determine links
              for (k=0; k<data.links.length; ++k) {
                var e = data.links[k],
                    u = index(e.source),
                    v = index(e.target);
              if (u != v) {
                gm[u].link_count++;
                gm[v].link_count++;
              }
                u = expand[u] ? nm[e.source.name] : nm[u];
                v = expand[v] ? nm[e.target.name] : nm[v];
                var i = (u<v ? u+"|"+v : v+"|"+u),
                    l = lm[i] || (lm[i] = {source:u, target:v, value:e.value, size:0});
                l.size += 1;
              }
              for (i in lm) { links.push(lm[i]); }
            
              return {nodes: nodes, links: links};
            }
            
            function convexHulls(nodes, index, offset) {
              var hulls = {};
            
              // create point sets
              for (var k=0; k<nodes.length; ++k) {
                var n = nodes[k];
                if (n.size) continue;
                var i = index(n),
                    l = hulls[i] || (hulls[i] = []);
                l.push([n.x-offset, n.y-offset]);
                l.push([n.x-offset, n.y+offset]);
                l.push([n.x+offset, n.y-offset]);
                l.push([n.x+offset, n.y+offset]);
              }
            
              // create convex hulls
              var hullset = [];
              for (i in hulls) {
                hullset.push({group: i, path: d3.geom.hull(hulls[i])});
              }
            
              return hullset;
            }
            
            function drawCluster(d) {
              return curve(d.path); // 0.8
            }
            
            //Fonction de Zoom
            function zoom() {
              vis.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
            }
            
            // --------------------------------------------------------
            
            var compteur=0;
            
            var body = d3.select("body");
            
            var vis = body.append("svg")
               .attr("width", window.innerWidth-50)
               .attr("height", window.innerHeight-220)
               .append("g")
               .call(d3.behavior.zoom().scaleExtent([-8, 8]).on("zoom", zoom))
               .append("g");
            
            // Construction des flèches
            vis.append("svg:defs").selectAll("marker")
                .data(["end"])      
              .enter().append("svg:marker")
                .attr("id", String)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 19)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
              .append("svg:path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill","#4d4d4d");
            
            d3.json("source.json", function(json) {
              data = json;
              
              function createSelect(options){
            $.each(options,function(index,item){
            $("#search").append($("<option></option>").attr("value", item.name).text(item.name));
            
            });
            }
            
            $(document).ready(function(){
            createSelect(json.nodes);
            });
            
              for (var i=0; i<data.links.length; ++i) {
                o = data.links[i];
                o.source = data.nodes[o.source];
                o.target = data.nodes[o.target];
              }
            
              hullg = vis.append("g");
              linkg = vis.append("g");
              nodeg = vis.append("g");
            
              init();
            
              vis.attr("opacity", 1e-6)
                .transition()
                  .duration(1000)
                  .attr("opacity", 1);
            
            });
            
            function init() {
              if (force) force.stop();
            
              net = network(data, net, getGroup, expand);
            
              force = d3.layout.force()
                  .nodes(net.nodes)
                  .links(net.links)
                  .size([window.innerWidth, window.innerHeight-150])
                  .linkDistance(function(l, i) {
                  var n1 = l.source, n2 = l.target;
                // larger distance for bigger groups:
                // both between single nodes and _other_ groups (where size of own node group still counts),
                // and between two group nodes.
                //
                // reduce distance for groups with very few outer links,
                // again both in expanded and grouped form, i.e. between individual nodes of a group and
                // nodes of another group or other group node or between two group nodes.
                //
                // The latter was done to keep the single-link groups ('blue', rose, ...) close.
                return 180 +
                  Math.min(40 * Math.min((n1.size || (n1.group != n2.group ? n1.group_data.size : 0)),
                                         (n2.size || (n1.group != n2.group ? n2.group_data.size : 0))),
                       -60 +
                       60 * Math.min((n1.link_count || (n1.group != n2.group ? n1.group_data.link_count : 0)),
                                     (n2.link_count || (n1.group != n2.group ? n2.group_data.link_count : 0))),
                       100);
                  //return 150;
                })
                .linkStrength(function(l, i) {
                return 1;
                })
                .gravity(0.025)   // gravity+charge tweaked to ensure good 'grouped' view (e.g. green group not smack between blue&orange, ...
                .charge(-4000)    // ... charge is important to turn single-linked groups to the outside
                .friction(0.5)   // friction adjusted to get dampened display: less bouncy bouncy ball [Swedish Chef, anyone?]
                .start();
                
              hullg.selectAll("path.hull").remove();
              hull = hullg.selectAll("path.hull")
                  .data(convexHulls(net.nodes, getGroup, off))
                .enter().append("path")
                  .attr("class", "hull")
                  .attr("d", drawCluster)
                  .style("fill", function(d) { return fill(d.group); })
                  .on("click", function(d) {
            console.log("hull click", d, arguments, this, expand[d.group]);
                  expand[d.group] = false; init();
                });
            
              link = linkg.selectAll("line.link").data(net.links, linkid);
              link.exit().remove();
              link.enter().append("line")
                  .attr("class", "link")
                  .attr("x1", function(d) { return d.source.x; })
                  .attr("y1", function(d) { return d.source.y; })
                  .attr("x2", function(d) { return d.target.x; })
                  .attr("y2", function(d) { return d.target.y; })
                  .attr("marker-end", "url(#end)")
                  .attr("stroke-width", 2)
                  .on("mouseover", function(d) { 
              		if (d3.event.shiftKey) {
              			d3.select(this).classed('action', false);
                		if (d.source.group === d.target.group) {
                			d3.select(this).classed('transition_action', false);
              			}
              			d3.select(this).classed('recent', true);
                		if (d.source.group === d.target.group) {
                			d3.select(this).classed('transition_recent', true);
              			}
            } 
            if (d3.event.ctrlKey) {
            d3.select(this).classed('recent', false);
                		if (d.source.group === d.target.group) {
                			d3.select(this).classed('transition_recent', false);
              			}
            d3.select(this).classed('action', false);
                		if (d.source.group === d.target.group) {
                			d3.select(this).classed('transition_action', false);
              			}
            } 
            if (d3.event.altKey) {
            d3.select(this).classed('recent', false);
                		if (d.source.group === d.target.group) {
                			d3.select(this).classed('transition_recent', false);
              			}
              			d3.select(this).classed('action', true);
                		if (d.source.group === d.target.group) {
                			d3.select(this).classed('transition_action', true);
              			}
            } 
            })
                  .attr('stroke', function (d) {
              		if (d.source.group === d.target.group) {
                		d3.select(this).classed('transition', true);
              		}
              		if (d.value == 1) {
                		d3.select(this).classed('action', true);
                		if (d.source.group === d.target.group) {
                			d3.select(this).classed('transition_action', true);
              			}
              		}
              		if (d.value == 2) {
                		d3.select(this).classed('recent', true);
                		if (d.source.group === d.target.group) {
                			d3.select(this).classed('transition_recent', true);
              			}
              		}
              		});
            
              node = nodeg.selectAll("g.node").data(net.nodes, nodeid);
              node.exit().remove();
              var onEnter = node.enter();   
              var g = onEnter
              	.append("g")
              	.attr("class", function(d) { return "node" + (d.size?"":" leaf"); })
              	.attr("transform", function(d) { 
                return "translate(" + d.x + "," + d.y + ")"; 
              });
              
              g.append("circle")
              	// if (d.size) -- d.size > 0 when d is a group node.      
              	.attr("r", function(d) { return d.size ? d.size + dr : dr+1; })
              	.style("fill", function(d) { return fill(d.group); })
              	.style("stroke", "black")
              	.attr('stroke-width', function (d) {
              		if (d.value == 1) {
              			return 2;
              		}
              		else {
              			return 0;
              		}
              		})
              	.on("mousedown", function(d) { d.fixed = true; })
              	.on("mouseover", function(d) { 
              		if (d3.event.shiftKey) {
              			d3.select(this).classed('non-active', false);
              			d3.select(this).classed('active', true);
            } 
            if (d3.event.ctrlKey) {
            d3.select(this).classed('active', false);
              			d3.select(this).classed('non-active', true);
            } 
            })
              	.on("click", function(d) {
                	expand[d.group] = !expand[d.group];
                	init();
              	});
              
              g.append("text")
              	.text(function(d,i){
                if (!d.size){
                	if (d.level==0) {
                		return d.level+" . . . "+d.gene;
                	}
                	else {
                		return d.level;
                	}
                }
                else {
                	return ". . . "+d.gene;
                }
            });
            
              node.call(force.drag);
            
              force.on("tick", function() {
                if (!hull.empty()) {
                  hull.data(convexHulls(net.nodes, getGroup, off))
                      .attr("d", drawCluster);
                }
            
                link.attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });
            
                node.attr("transform", function(d) { 
               		return "translate(" + d.x + "," + d.y + ")"; 
             	});
             	
             	compteur=compteur+1;
             	if(compteur==1){
             		$("circle").d3Click();
             	}
                    
              });
            }
            
            function searchNode() {
                //find the node
                
                var selectedVal = document.getElementById('search').value;
                var node = vis.selectAll("circle");
                if (selectedVal == "none") {
               	 node.style("stroke", "white").style("stroke-width", "1");
                } else {
                    var selected = node.filter(function (d, i) {
                        return d.name != selectedVal;
                    });
                    selected.style("opacity", "0");
                    var link = vis.selectAll("line.link");
                    link.style("opacity", "0");
                    var text = vis.selectAll("text")
                    text.style("opacity", "0");
                    var hull = vis.selectAll("path.hull")
                    hull.style("opacity", "0");
                    d3.selectAll("circle, line.link, text, path.hull").transition()
                        .duration(5000)
                        .style("opacity", 1);
                }
            }    
        </script>
    </body>
</html>